## 実行したコマンド / ファイル作成 (supabase の設定は除く)
```
% npx create-next-app --example with-tailwindcss rsc-supabase --use-npm
  # → --example with-tailwindcss: 予め tailwindcss の設定がされている example を使う
  # → rsc-supabase: プロジェクト名

% npm i @heroicons/react@2.0.17 @supabase/auth-helpers-nextjs@0.6.1 @supabase/supabase-js@2.21.0 zustand@4.3.8 supabase@1.55.1 date-fns@2.30.0
  # → heroicons、supabase、zustand、date-fns をインストール

% npm i next@13.4.1
  # → next.jsのバージョンを 13.4.1 に合わせる
```
① プロジェクト直下に prettierrc というファイルを作成し、その中に以下を記述↓  
```
{
  "singleQuote": true,
  "semi": false
}
```
② next.jsのバージョンが 13.4以下の場合は プロジェクト直下にある next.config.js を開き、以下を追記。  
↓ バージョンが 13.4以上の場合は、app routerの安定版に更新されている為設定は不要。  
```
/** @type {import('next').NextConfig} */
module.exports = {
  reactStrictMode: true,

  /*↓ 以下を追記*/
  experimental: {
    appDir: true,
  },
}
```
③ next.jsのバージョンが 13.4以前の場合は app/head.tsx というファイルを作る必要がある。<Head>タグにの中に書くものを設定するところ。以下を記述↓

```
export default function Head() {
  return (
    <>
      <title>Nextjs App</title>
      <meta content="width=devise-width, initial-scale=1" name="viewport" />
      <meta name="description" content="Generated by create next app" />
      <link rel="icon" href="/favicon.ico" />
    </>
  )
}
```
13.4以降の場合は、app/head.tsx は作らずに、ルートレイアウトのファイルに以下を追記する↓  
```
import './globals.css'

// ↓以下を追記
export const metadata = {
  title: 'Nextjs App',
  description: 'Generated by create next App',
}

export default function RootLayout ({...
```

## cache: 'force-cache'
Next.js12 の時の getStaticPropsしたものに近い。  
Next.js13 でも引き続き defaultの挙動となっているが、13.4以降は fetch単位で cacheオプションを指定する必要がある。  
ネットワークからのレスポンスをキャッシュせず、常にキャッシュされたリソースを使用することを示す。  
つまり、リソースがキャッシュに保存されている場合でも、ネットワークリクエストが行われ、レスポンスが再度キャッシュに保存され、常に最新のデータを取得しようとする場合に使用される。  
```
fetch(url, {
  method: "GET",
  cache: "force-cache"
})
```


## next: { revalidate: 10 }
Next.js12 の時の getStaticPropsで revalidateしたものに近い。  
データのリソース再取得を制御するためのオプション。  
このオプションを使用することで、ページのデータを定期的に再取得して最新の情報を提供することができる。
```
fetch(url, {
  next: { revalidate: 10 },  // 10秒ごとに再取得を試みる
})
```
上の例では、関数内の fetch時に revalidate オプションを設定。データは最初に取得された後、10秒ごとにデータが再取得される。  
主に静的生成（SSG）モードのページで使用されることが一般的。  
例えば、特定のページのデータが時間の経過とともに変化する場合に、定期的に最新のデータを取得して表示するなど。  
しかし、revalidate を過剰に短い間隔で設定すると、サーバーへの負荷が増加する可能性があるため、適切な間隔を選ぶことが重要。  


## cache: 'no-store'
Next.js12 の時の getServerSidePropsしたものに近い。  
ブラウザーが特定のリクエストに対してキャッシュを使用しないように指示する。  
リクエストごとに必ずサーバーからデータを取得し、キャッシュを無効化する。
```
const response = await fetch(url, {
  cache: 'no-store', // キャッシュを使用しない
});
```
上のコードは、指定されたURLに対してリクエストを行う際に、キャッシュを使用せずに常にサーバーからデータを取得することを指示している。  
リアルタイムなデータやセンシティブな情報の場合、特にAPIリクエストなどで頻繁に使用される。  
サーバーサイドから返されるHTTPヘッダーにこの指示が含まれていれば、ブラウザーはキャッシュを使用せずに常に新しいデータを取得することになる。  
しかし、キャッシュを無効化するため、リクエストごとにサーバーへの負荷が増加する可能性があることに注意が必要。  


## generateStaticParams()
generateStaticParams 関数を利用することで Dynamic Routes もビルド時に静的なファイルとして作成することができる。  
generateStaticParams を利用して id の値を blogs/[blogId]/page.tsx ファイルで Next.js に教えてあげる必要がある。  
Next.js12では、getStaticPaths()を使って、id一覧を生成・取得していたが、 Next.js13 からは generateStaticParams 関数内での動的fetch()リクエストにより一覧データを fetch → 取得した blog一覧から idだけを取り出し、文字列に変換して配列 blogId に格納 → blogIdを returnで返す、という一連の流れを個々のサーバーコンポーネントで実行できるようになった。  
```
export async function generateStaticParams() {
  const res = await fetch(`${process.env.url}/rest/v1/blogs?select=*`, {
    headers: new Headers({
      apikey: process.env.apikey as string,
    }),
  })
  const blogs: Blog[] = await res.json()

  return blogs.map((blog) => ({
    blogId: blog.id.toString(),
    // blogId: ダイナミックセグメントの値と紐づくプロパティ。ダイナミックセグメントの値は、文字列である必要があるため、blog.idを文字列に変換
  }))
}
```
上で return した blogId を元に、事前に blog個別ページが SSGで生成され、タイトルの 1つをクリックすると blog個別ページを表示する関数の引数に params として blogId が渡され、1つの blog個別ページが fetchされ、そのサーバーコンポーネント内の returnで HTMLとして表示していく。


## useRouter の router.push
useRouterは、クライアントコンポーネントのみで import可能。
router.push で遷移されたページは、Next.js13.4以前までは、毎回ハードナビゲーションが適用されていたが、13.4以降は初回のみハードナビゲーション、2回目以降はソフトナビゲーションが適用されてレンダリングされる。
※ ちなみに、ダイナミックセグメント([blogId]のようなファイルルーティング)でルーティングされたページは、URLの[blogId]部分が変更される度に毎回、ハードナビゲーションが適用されてレンダリングされる。